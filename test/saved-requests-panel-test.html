<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>saved-requests-panel test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>

  <script src="../../../web-animations-js/web-animations-next.min.js"></script>
</head>

<body>
  <test-fixture id="Basic">
    <template>
      <saved-requests-panel no-auto no-auto-projects></saved-requests-panel>
    </template>
  </test-fixture>

  <test-fixture id="Models">
    <template>
      <request-model></request-model>
      <project-model></project-model>
      <saved-requests-panel></saved-requests-panel>
    </template>
  </test-fixture>

  <script type="module">
  import {DataGenerator} from '../../arc-data-generator/arc-data-generator.js';
  import '../../../@advanced-rest-client/arc-models/request-model.js';
  import '../../../@advanced-rest-client/arc-models/project-model.js';
  import sinon from '../../../sinon/pkg/sinon-esm.js';
  import '../saved-requests-panel.js';
  /* global chance */
  function doneAfterQuery(element, done) {
    element.addEventListener('querying-changed', function f(e) {
      if (e.detail.value) {
        return;
      }
      element.removeEventListener('querying-changed', f);
      flush(() => done());
    });
  }

  suite('_computeA11yCommand()', () => {
    let element;
    setup(function() {
      element = fixture('Basic');
    });

    test('Returns passed letter with CMD/CTRL', () => {
      const result = element._computeA11yCommand('s');
      assert.isTrue(/(meta|ctrl)\+s/.test(result));
    });
  });

  suite('notifyResize()', () => {
    test('Do nothing when DOM is not initialized', () => {
      const element = fixture('Basic');
      element.notifyResize();
    });

    test('Calls list\'s notifyResize', (done) => {
      const element = fixture('Basic');
      flush(() => {
        const list = element.shadowRoot.querySelector('saved-panel-list');
        let called = false;
        list.notifyResize = () => called = true;
        element.notifyResize();
        assert.isTrue(called);
        done();
      });
    });
  });

  suite('_computeListHidden()', () => {
    let element;
    suiteSetup(() => {
      element = fixture('Basic');
    });

    test('Returns false when isSearch is true', () => {
      let result = element._computeListHidden(true, true);
      assert.isFalse(result);
      result = element._computeListHidden(false, true);
      assert.isFalse(result);
    });

    test('Returns false when hasRequests is true', () => {
      let result = element._computeListHidden(true);
      assert.isFalse(result);
    });

    test('Returns true when hasRequests is false', () => {
      let result = element._computeListHidden(false);
      assert.isTrue(result);
    });
  });

  suite('_navigateHandler()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Sets detailsOpened to false', () => {
      element.detailsOpened = true;
      element._navigateHandler();
      assert.isFalse(element.detailsOpened);
    });
  });

  suite('_onDetails()', () => {
    let element;
    let eData;
    setup((done) => {
      element = fixture('Basic');
      eData = {
        detail: {
          request: DataGenerator.generateSavedItem()
        }
      };
      flush(() => done());
    });

    test('Sets request on request details dialog', () => {
      element._onDetails(eData);
      assert.isTrue(eData.detail.request === element.$.requestDetails.request);
    });

    test('Opens request details dialog', () => {
      element._onDetails(eData);
      assert.isTrue(element.detailsOpened);
    });
  });

  suite('_loadRequestDetails()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      flush(() => {
        element.$.requestDetails.request = {
          _id: 'test'
        };
        done();
      });
    });

    test('Dispatches "navigate" event', () => {
      const spy = sinon.spy();
      element.addEventListener('navigate', spy);
      element._loadRequestDetails();
      assert.isTrue(spy.called);
    });

    test('The event has base', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e.detail;
      });
      element._loadRequestDetails();
      assert.equal(data.base, 'request');
    });

    test('The event has type', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e.detail;
      });
      element._loadRequestDetails();
      assert.equal(data.type, 'saved');
    });

    test('The event has id', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e.detail;
      });
      element._loadRequestDetails();
      assert.equal(data.id, 'test');
    });

    test('The event bubbles', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e;
      });
      element._loadRequestDetails();
      assert.isTrue(data.bubbles);
    });

    test('The event is composed', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e;
      });
      element._loadRequestDetails();
      if (typeof data.composed !== 'undefined') {
        assert.isTrue(data.composed);
      }
    });

    test('The event is cancelable', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e;
      });
      element._loadRequestDetails();
      assert.isTrue(data.cancelable);
    });
  });

  suite('_searchHandler()', () => {
    let element;
    let arg;
    setup((done) => {
      element = fixture('Basic');
      arg = {
        target: {
          value: 'test'
        }
      };
      flush(() => done());
    });

    test('Calls query() function', () => {
      let called = false;
      element.query = () => called = true;
      element._searchHandler(arg);
      assert.isTrue(called);
    });

    test('Passes value to query function', () => {
      let value;
      element.query = (input) => value = input;
      element._searchHandler(arg);
      assert.equal(value, 'test');
    });
  });

  suite('_deleteSelected()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      flush(() => done());
    });

    test('Closes the selection menu', () => {
      let called = false;
      element._closeSelectionMenu = () => called = true;
      element._deleteSelected();
      assert.isTrue(called);
    });

    test('Calls delete function', () => {
      const arr = ['a', 'b', 'c'];
      element.selectedItems = arr;
      let value;
      element._delete = (input) => value = input;
      element._deleteSelected();
      assert.deepEqual(value, arr);
    });

    test('Does nothing when no selection', () => {
      let called = false;
      element._delete = () => called = true;
      element._deleteSelected();
      assert.isFalse(called);
    });
  });

  suite('_deleteRequestDetails()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      flush(() => {
        element.$.requestDetails.request = DataGenerator.generateSavedItem();
        done();
      });
    });

    test('Calls delete function', () => {
      let value;
      element._delete = (input) => value = input;
      element._deleteRequestDetails();
      assert.typeOf(value, 'array');
      assert.lengthOf(value, 1);
    });

    test('Sets detailsOpened to false', () => {
      element.detailsOpened = true;
      element._delete = () => {};
      element._deleteRequestDetails();
      assert.isFalse(element.detailsOpened);
    });
  });

  suite('_dispatchDelete()', () => {
    let element;
    let list;
    setup(() => {
      element = fixture('Basic');
      list = DataGenerator.generateRequests({
        requestsSize: 5
      });
    });

    test('Dispatches request-objects-deleted event', () => {
      const spy = sinon.spy();
      element.addEventListener('request-objects-deleted', spy);
      element._dispatchDelete(list);
      assert.isTrue(spy.called);
    });

    test('The event bubbles', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e;
      });
      element._dispatchDelete(list);
      assert.isTrue(data.bubbles);
    });

    test('The event is composed', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e;
      });
      element._dispatchDelete(list);
      if (typeof data.composed !== 'undefined') {
        assert.isTrue(data.composed);
      }
    });

    test('The event is cancelable', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e;
      });
      element._dispatchDelete(list);
      assert.isTrue(data.cancelable);
    });

    test('The event has "detail.type"', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e.detail;
      });
      element._dispatchDelete(list);
      assert.equal(data.type, 'saved');
    });

    test('The event has "detail.items"', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e.detail;
      });
      element._dispatchDelete(list);
      assert.typeOf(data.items, 'array');
      assert.lengthOf(data.items, 5);
    });

    test('The "detail.items" are IDs', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e.detail;
      });
      element._dispatchDelete(list);
      assert.typeOf(data.items[0], 'string');
    });
  });

  suite('_delete()', () => {
    teardown(() => {
      return DataGenerator.destroySavedRequestData();
    });

    let element;
    setup((done) => {
      DataGenerator.insertSavedRequestData({
        requestsSize: 5
      })
      .then(() => {
        element = fixture('Models')[2];
        doneAfterQuery(element, done);
      });
    });

    test('Dispatches request-objects-deleted event', () => {
      const spy = sinon.spy();
      element.addEventListener('request-objects-deleted', spy);
      const p = element._delete(element.requests.slice(0, 2));
      assert.isTrue(spy.called);
      return p;
    });

    test('Opens model error toast if the event is not handled', function() {
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        e.stopImmediatePropagation();
      });
      return element._delete(element.requests.slice(0, 2))
      .catch(() => {
        const toast = element.shadowRoot.querySelector('#noModel');
        assert.isTrue(toast.opened);
      });
    });

    test('Sets _latestDeleted', () => {
      return element._delete(element.requests.slice(0, 2))
      .then(() => {
        assert.typeOf(element._latestDeleted, 'array');
        assert.lengthOf(element._latestDeleted, 2);
      });
    });

    test('_latestDeleted has _id and _rev', () => {
      return element._delete(element.requests.slice(0, 2))
      .then(() => {
        const item = element._latestDeleted[0];
        assert.typeOf(item._id, 'string');
        assert.typeOf(item._rev, 'string');
      });
    });

    test('Opens delete confirmation toast', () => {
      return element._delete(element.requests.slice(0, 2))
      .then(() => {
        assert.isTrue(element.$.deleteToast.opened);
      });
    });

    test('Deletes single request', () => {
      return element._delete(element.requests.slice(0, 1))
      .then(() => {
        assert.equal(element.$.deleteToast.text, 'The request has been removed.');
      });
    });
  });

  suite('_dispatchUndelete()', () => {
    let element;
    let list;
    setup(() => {
      element = fixture('Basic');
      list = [];
      for (let i = 0; i < 5; i++) {
        list[i] = {
          _id: chance.guid({version: 5}),
          _rev: chance.guid({version: 5})
        };
      }
    });

    test('Dispatches request-objects-undeleted event', () => {
      const spy = sinon.spy();
      element.addEventListener('request-objects-undeleted', spy);
      element._dispatchUndelete(list);
      assert.isTrue(spy.called);
    });

    test('The event bubbles', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e;
      });
      element._dispatchUndelete(list);
      assert.isTrue(data.bubbles);
    });

    test('The event is composed', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e;
      });
      element._dispatchUndelete(list);
      if (typeof data.composed !== 'undefined') {
        assert.isTrue(data.composed);
      }
    });

    test('The event is cancelable', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e;
      });
      element._dispatchUndelete(list);
      assert.isTrue(data.cancelable);
    });

    test('The event has "detail.type"', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e.detail;
      });
      element._dispatchUndelete(list);
      assert.equal(data.type, 'saved');
    });

    test('The event has "detail.items"', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e.detail;
      });
      element._dispatchUndelete(list);
      assert.typeOf(data.items, 'array');
      assert.lengthOf(data.items, 5);
    });

    test('The "detail.items" has _id and _rev', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e.detail;
      });
      element._dispatchUndelete(list);
      assert.typeOf(data.items[0]._id, 'string');
      assert.typeOf(data.items[0]._rev, 'string');
    });
  });

  suite('revertDeleted()', () => {
    teardown(() => {
      return DataGenerator.destroySavedRequestData();
    });

    let element;
    setup((done) => {
      DataGenerator.insertSavedRequestData({
        requestsSize: 5
      })
      .then(() => {
        element = fixture('Models')[2];
        doneAfterQuery(element, done);
      });
    });

    test('Do nothing when delete was not called before', function() {
      return element.revertDeleted(); // no error is thrown
    });

    test('Closes delete confirmation toast', function() {
      return element._delete(element.requests.slice(0, 2))
      .then(() => {
        const promise = element.revertDeleted();
        assert.isFalse(element.$.deleteToast.opened);
        return promise;
      });
    });

    test('Dispatches request-objects-undeleted event', function() {
      const spy = sinon.spy();
      element.addEventListener('request-objects-undeleted', spy);
      return element._delete(element.requests.slice(0, 2))
      .then(() => {
        const promise = element.revertDeleted();
        assert.isTrue(spy.calledOnce);
        return promise;
      });
    });

    test('Undeleted restores items to the list', function() {
      const deleted = [element.requests[2], element.requests[3]];
      const sizeBefore = element.requests.length;
      return element._delete(deleted)
      .then(() => {
        assert.notEqual(element.requests.length, sizeBefore);
        return element.revertDeleted();
      })
      .then(() => {
        assert.equal(element.requests.length, sizeBefore);
      });
    });

    test('Opens model error toast if the event is not handled', function() {
      element._latestDeleted = [{}];
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        e.stopImmediatePropagation();
      });
      return element.revertDeleted()
      .catch(() => {
        const toast = element.shadowRoot.querySelector('#noModel');
        assert.isTrue(toast.opened);
      });
    });

    test('Opens revert error toast if there\'s an error', function() {
      element._latestDeleted = [{}];
      element._handleError = () => {};
      return element.revertDeleted()
      .catch(() => {
        const toast = element.shadowRoot.querySelector('#revertError');
        assert.isTrue(toast.opened);
      });
    });
  });

  suite('DOM manipulation', () => {
    suite('No data', () => {
      suiteSetup(() => {
        return DataGenerator.destroySavedRequestData();
      });

      let element;
      setup((done) => {
        element = fixture('Models')[2];
        doneAfterQuery(element, done);
      });

      test('hasRequests is false', () => {
        assert.isFalse(element.hasRequests);
      });

      test('empty message is rendered', () => {
        const node = element.shadowRoot.querySelector('.empty-info');
        assert.ok(node);
      });

      test('The list is hidden', () => {
        const list = element.shadowRoot.querySelector('saved-panel-list');
        assert.isTrue(list.hasAttribute('hidden'));
      });

      test('Selection menu is hidden', () => {
        const list = element.shadowRoot.querySelector('.selection-options');
        assert.isTrue(list.hasAttribute('hidden'));
      });
    });

    suite('With data', () => {
      suiteSetup(() => {
        return DataGenerator.insertSavedRequestData();
      });

      suiteTeardown(() => {
        return DataGenerator.destroySavedRequestData();
      });

      let element;
      setup((done) => {
        element = fixture('Models')[2];
        doneAfterQuery(element, done);
      });

      test('hasRequests is true', () => {
        assert.isTrue(element.hasRequests);
      });

      test('empty message is not rendered', () => {
        const node = element.shadowRoot.querySelector('.empty-info');
        const display = getComputedStyle(node).display;
        assert.equal(display, 'none');
      });

      test('The list is visible', () => {
        const list = element.shadowRoot.querySelector('saved-panel-list');
        assert.isFalse(list.hasAttribute('hidden'));
      });

      test('Selection menu is visible', () => {
        const list = element.shadowRoot.querySelector('.selection-options');
        assert.isFalse(list.hasAttribute('hidden'));
      });
    });
  });

  suite('_closeSelectionMenu()', () => {
    let element;
    let list;
    setup(() => {
      element = fixture('Basic');
      list = [];
      for (let i = 0; i < 5; i++) {
        list[i] = {
          _id: chance.guid({version: 5}),
          _rev: chance.guid({version: 5})
        };
      }
    });

    test('Does nothing when menu is not in the DOM', () => {
      element._closeSelectionMenu();
      // no error
    });

    test('Closes the menu', (done) => {
      element.requests = list;
      element.selectedItems = list;
      flush(() => {
        const menu = element.shadowRoot.querySelector('#savedListMenu');
        menu.opened = true;
        element._closeSelectionMenu();
        assert.isFalse(menu.opened);
        done();
      });
    });

    test('Re-sets list selection', (done) => {
      element.requests = list;
      element.selectedItems = list;
      flush(() => {
        const menu = element.shadowRoot.querySelector('#savedListMenuOptions');
        menu.selected = 1;
        element._closeSelectionMenu();
        assert.equal(menu.selected, -1);
        done();
      });
    });
  });

  suite('_closeMainMenu()', () => {
    let element;
    let list;
    setup(() => {
      element = fixture('Basic');
      list = [];
      for (let i = 0; i < 5; i++) {
        list[i] = {
          _id: chance.guid({version: 5}),
          _rev: chance.guid({version: 5})
        };
      }
    });

    test('Closes the main menu', (done) => {
      element.requests = list;
      flush(() => {
        const menu = element.shadowRoot.querySelector('#mainMenu');
        menu.opened = true;
        element._closeMainMenu();
        assert.isFalse(menu.opened);
        done();
      });
    });

    test('Re-sets list selection', (done) => {
      element.requests = list;
      flush(() => {
        const menu = element.shadowRoot.querySelector('#mainMenuOptions');
        menu.selected = 1;
        element._closeMainMenu();
        assert.equal(menu.selected, -1);
        done();
      });
    });
  });

  suite('_deleteAllClick()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      flush(() => done());
    });

    test('Closes main menu', () => {
      const menu = element.shadowRoot.querySelector('#mainMenu');
      menu.opened = true;
      element._deleteAllClick();
      assert.isFalse(menu.opened);
    });

    test('Opens data clear dialog', () => {
      const dialog = element.shadowRoot.querySelector('#dataClearDialog');
      element._deleteAllClick();
      assert.isTrue(dialog.opened);
    });
  });

  suite('_dispatchDeleteModel()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Dispatches "destroy-model" event', () => {
      const spy = sinon.spy();
      element.addEventListener('destroy-model', spy);
      element._dispatchDeleteModel();
      assert.isTrue(spy.called);
    });

    test('Returns the event', () => {
      const result = element._dispatchDeleteModel();
      assert.typeOf(result, 'customevent');
    });

    test('Event is cancelable', () => {
      const result = element._dispatchDeleteModel();
      assert.isTrue(result.cancelable);
    });

    test('Event is composed', () => {
      const result = element._dispatchDeleteModel();
      if (typeof result.composed !== 'undefined') {
        assert.isTrue(result.composed);
      }
    });

    test('Event bubbles', () => {
      const result = element._dispatchDeleteModel();
      assert.isTrue(result.bubbles);
    });

    test('Event has detail object', () => {
      const result = element._dispatchDeleteModel();
      assert.typeOf(result.detail, 'object');
    });

    test('Detail has models', () => {
      const result = element._dispatchDeleteModel();
      assert.typeOf(result.detail.models, 'array');
    });

    test('Models has "saved" item', () => {
      const result = element._dispatchDeleteModel();
      assert.deepEqual(result.detail.models, ['saved']);
    });
  });

  suite('_clearDatastore()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Opens error toast when model is not found', (done) => {
      flush(() => {
        element._handleError = () => {};
        element._clearDatastore();
        const toast = element.shadowRoot.querySelector('#dataClearErrorToast');
        assert.isTrue(toast.opened);
        done();
      });
    });

    test('Throws error when no model', () => {
      assert.throws(() => {
        element._clearDatastore();
      }, 'Model not found.');
    });

    test('Opens error when model delete error', (done) => {
      element._handleError = () => {};
      element.addEventListener('destroy-model', function f(e) {
        element.removeEventListener('destroy-model', f);
        e.detail.result = [Promise.reject(new Error('test'))];
      });
      element._clearDatastore();
      flush(() => {
        const toast = element.shadowRoot.querySelector('#dataClearErrorToast');
        assert.isTrue(toast.opened);
        done();
      });
    });
  });

  suite('_onClearDialogResult()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Does nothing when dialog is not confirmed', () => {
      const spy = sinon.spy(element, '_clearDatastore');
      element._onClearDialogResult({
        detail: {
          confirmed: false
        }
      });
      assert.isFalse(spy.called);
    });

    test('Calls _clearDatastore() when confirmed', () => {
      const spy = sinon.spy(element, '_clearDatastore');
      element.addEventListener('destroy-model', function f(e) {
        element.removeEventListener('destroy-model', f);
        e.detail.result = [Promise.resolve()];
      });
      element._onClearDialogResult({
        detail: {
          confirmed: true
        }
      });
      assert.isTrue(spy.called);
    });
  });

  suite('_editRequestDetails()', () => {
    let element;
    let request;
    setup((done) => {
      element = fixture('Basic');
      flush(() => {
        request = DataGenerator.generateSavedItem();
        const details = element.shadowRoot.querySelector('#requestDetails');
        details.request = request;
        element.detailsOpened = true;
        done();
      });
    });

    test('Closes request details dialog', () => {
      element._editRequestDetails();
      assert.isFalse(element.detailsOpened);
    });

    test('Opens request editor dialog', () => {
      element._editRequestDetails();
      assert.isTrue(element.editorOpened);
    });

    test('Clears request on detail dialog', () => {
      element._editRequestDetails();
      const details = element.shadowRoot.querySelector('#requestDetails');
      assert.isUndefined(details.request);
    });

    test('Sets request on editor dialog', () => {
      element._editRequestDetails();
      const editor = element.shadowRoot.querySelector('#requestEditor');
      assert.typeOf(editor.request, 'object');
    });

    test('Set request is a shallow copy', () => {
      element._editRequestDetails();
      const editor = element.shadowRoot.querySelector('#requestEditor');
      editor.request.url = 'test';
      assert.notEqual(request.url, 'test');
    });
  });

  suite('_cancelRequestEdit()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
      element.editorOpened = true;
    });

    test('Closes editor dialog', () => {
      element._cancelRequestEdit();
      assert.isFalse(element.editorOpened);
    });
  });

  suite('_saveRequestEdit()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      element.editorOpened = true;
      flush(() => {
        const editor = element.shadowRoot.querySelector('#requestEditor');
        editor.request = DataGenerator.generateSavedItem();
        done();
      });
    });

    test('Closes editor dialog', () => {
      element._saveRequestEdit();
      assert.isFalse(element.editorOpened);
    });

    test('Clears request from the editor', () => {
      element._saveRequestEdit();
      const editor = element.shadowRoot.querySelector('#requestEditor');
      assert.isUndefined(editor.request);
    });
  });

  suite('_projectSelected()', () => {
    let element;
    let list;
    setup((done) => {
      element = fixture('Basic');
      list = DataGenerator.generateRequests();
      element.requests = list;
      flush(() => {
        const node = element.shadowRoot.querySelector('#projectSelectorContainer');
        node.opened = false;
        done();
      });
    });

    test('Closes selection menu', () => {
      const spy = sinon.spy(element, '_closeSelectionMenu');
      element._projectSelected();
      assert.isTrue(spy.called);
    });

    test('Does nothing when no selection', () => {
      element._projectSelected();
      const node = element.shadowRoot.querySelector('#projectSelectorContainer');
      assert.isFalse(node.opened);
    });

    test('Opens project selector', () => {
      element.selectedItems = list;
      element._projectSelected();
      const node = element.shadowRoot.querySelector('#projectSelectorContainer');
      assert.isTrue(node.opened);
    });
  });

  suite('cancelAddProject()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      flush(() => {
        const node = element.shadowRoot.querySelector('#projectSelectorContainer');
        node.opened = true;
        done();
      });
    });

    test('Closes project selector', () => {
      element.cancelAddProject();
      const node = element.shadowRoot.querySelector('#projectSelectorContainer');
      assert.isFalse(node.opened);
    });
  });

  suite('_prepareProjectsIdsList()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Returns empty array when no arguments', () => {
      const result = element._prepareProjectsIdsList();
      assert.typeOf(result, 'array');
      assert.lengthOf(result, 0);
    });

    test('Returns passed "ids" when no "created"', () => {
      const result = element._prepareProjectsIdsList([], ['test']);
      assert.deepEqual(result, ['test']);
    });

    test('Adds ids from created', () => {
      const result = element._prepareProjectsIdsList([{_id: 'created'}], ['test']);
      assert.deepEqual(result, ['test', 'created']);
    });
  });

  suite('_updateRequestsProjects()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Creates "projects" property', () => {
      const result = element._updateRequestsProjects([{}], ['test']);
      assert.typeOf(result[0].projects, 'array');
      assert.deepEqual(result[0].projects, ['test']);
    });

    test('Adds "legacyProject" to "projects"', () => {
      const result = element._updateRequestsProjects([{
        legacyProject: 'legacy'
      }], ['test']);
      assert.typeOf(result[0].projects, 'array');
      assert.deepEqual(result[0].projects, ['legacy', 'test']);
    });

    test('Removes "legacyProject" from the request', () => {
      const result = element._updateRequestsProjects([{
        legacyProject: 'legacy'
      }], ['test']);
      assert.isUndefined(result[0].legacyProject);
    });

    test('Ignores "legacyProject" if already on "projects" list', () => {
      const result = element._updateRequestsProjects([{
        legacyProject: 'legacy',
        projects: ['legacy']
      }], ['test']);
      assert.deepEqual(result[0].projects, ['legacy', 'test']);
    });
  });

  suite('_createProjects()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    function factory(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve('test');
    }

    test('Disaptches project-update-bulk event', () => {
      const spy = sinon.spy();
      element.addEventListener('project-update-bulk', spy);
      element.addEventListener('project-update-bulk', factory);
      element._createProjects(['name-x'], ['request-x']);
      element.removeEventListener('project-update-bulk', factory);
      assert.isTrue(spy.called, 'Event is dispatched');
      assert.isTrue(spy.args[0][0].cancelable, 'Event is cancelable');
      assert.isTrue(spy.args[0][0].bubbles, 'Event bubbles');
    });

    test('Event has 2 projects', () => {
      const spy = sinon.spy();
      element.addEventListener('project-update-bulk', spy);
      element.addEventListener('project-update-bulk', factory);
      element._createProjects(['name-x', 'name-y'], ['request-x']);
      assert.lengthOf(spy.args[0][0].detail.projects, 2);
    });

    test('Each project has request IDs', () => {
      const spy = sinon.spy();
      element.addEventListener('project-update-bulk', spy);
      element.addEventListener('project-update-bulk', factory);
      element._createProjects(['name-x', 'name-y'], ['request-x']);
      element.removeEventListener('project-update-bulk', factory);
      const projects = spy.args[0][0].detail.projects;
      assert.deepEqual(projects[0].requests, ['request-x']);
      assert.deepEqual(projects[1].requests, ['request-x']);
    });

    test('Each project has name', () => {
      const spy = sinon.spy();
      element.addEventListener('project-update-bulk', spy);
      element.addEventListener('project-update-bulk', factory);
      element._createProjects(['name-x', 'name-y'], ['request-x']);
      element.removeEventListener('project-update-bulk', factory);
      const projects = spy.args[0][0].detail.projects;
      assert.equal(projects[0].name, 'name-x');
      assert.equal(projects[1].name, 'name-y');
    });

    test('Returns a promise', () => {
      element.addEventListener('project-update-bulk', factory);
      const result = element._createProjects(['name-x', 'name-y'], ['request-x']);
      element.removeEventListener('project-update-bulk', factory);
      assert.typeOf(result.then, 'function');
    });

    test('Rejects when no model', () => {
      return element._createProjects(['name-x', 'name-y'], ['request-x'])
      .then(() => {
        throw new Error('Should not resolve');
      })
      .catch((cause) => {
        assert.equal(cause.message, 'The project-model is not in the DOM.');
      });
    });
  });

  suite('openExportAll()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls _closeMainMenu()', () => {
      const spy = sinon.spy(element, '_closeMainMenu');
      element.openExportAll();
      assert.isTrue(spy.called);
    });

    test('Sets _exportOptionsOpened', () => {
      element.openExportAll();
      assert.isTrue(element._exportOptionsOpened);
    });

    test('Sets _exportItems', () => {
      element.openExportAll();
      assert.isTrue(element._exportItems);
    });
  });

  suite('_cancelExportOptions()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
      element._exportOptionsOpened = true;
      element._exportItems = true;
    });

    test('Sets _exportOptionsOpened', () => {
      element._cancelExportOptions();
      assert.isFalse(element._exportOptionsOpened);
    });

    test('Sets _exportItems', () => {
      element._cancelExportOptions();
      assert.isUndefined(element._exportItems);
    });
  });

  suite('_exportAllFile()', () => {
    function handler(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve();
    }

    let element;
    setup(() => {
      element = fixture('Basic');
      window.addEventListener('arc-data-export', handler);
    });

    teardown(() => {
      window.removeEventListener('arc-data-export', handler);
    });

    test('Calls _doExportItems()', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.isTrue(spy.called);
      return result;
    });

    test('First argument is true', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.isTrue(spy.args[0][0]);
      return result;
    });

    test('Second argument has options', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.typeOf(spy.args[0][1].options, 'object');
      return result;
    });

    test('Options has file', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.equal(spy.args[0][1].options.file, element._generateFileName());
      return result;
    });

    test('Options has kind', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.equal(spy.args[0][1].options.kind, 'ARC#SavedExport');
      return result;
    });

    test('Options has provider', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.equal(spy.args[0][1].options.provider, 'file');
      return result;
    });
  });

  suite('_acceptExportOptions()', () => {
    function handler(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve();
    }

    let element;
    setup(() => {
      element = fixture('Basic');
      window.addEventListener('arc-data-export', handler);
    });

    teardown(() => {
      window.removeEventListener('arc-data-export', handler);
    });

    test('Sets _exportOptionsOpened', () => {
      const result = element._acceptExportOptions({
        detail: {
          options: {}
        }
      });
      assert.isFalse(element._exportOptionsOpened);
      return result;
    });

    test('Calls _doExportItems()', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._acceptExportOptions({
        detail: {
          options: {}
        }
      });
      assert.isTrue(spy.called);
      return result;
    });
  });

  suite('_updateListStyles()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls _applyListStyles() for default type', () => {
      const spy = sinon.spy(element, '_applyListStyles');
      element._updateListStyles('default');
      assert.equal(spy.args[0][0], 56);
      assert.ok(spy.args[0][1]);
    });

    test('Calls _applyListStyles() for comfortable type', () => {
      const spy = sinon.spy(element, '_applyListStyles');
      element._updateListStyles('comfortable');
      assert.equal(spy.args[0][0], 40);
      assert.ok(spy.args[0][1]);
    });

    test('Calls _applyListStyles() for compact type', () => {
      const spy = sinon.spy(element, '_applyListStyles');
      element._updateListStyles('compact');
      assert.equal(spy.args[0][0], 36);
      assert.ok(spy.args[0][1]);
    });
  });

  suite('_onExportSelected()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls _closeSelectionMenu()', () => {
      const spy = sinon.spy(element, '_closeSelectionMenu');
      element._onExportSelected();
      assert.isTrue(spy.called);
    });

    test('Sets _exportOptionsOpened', () => {
      element._onExportSelected();
      assert.isTrue(element._exportOptionsOpened);
    });

    test('Sets _exportItems', () => {
      element.selectedItems = [{test: true}];
      element._onExportSelected();
      assert.deepEqual(element._exportItems, element.selectedItems);
    });
  });

  suite('_addSelectedProject()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Throws when no selection', () => {
      assert.throws(() => {
        element._addSelectedProject();
      }, 'Something is wrong. There\'s no selection. You shouldn\'t see this.');
    });
  });

  suite('_projectAddKeydown()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
      element._addSelectedProject = () => {};
    });

    test('Ignores key when not Enter key', () => {
      const spy = sinon.spy(element, '_addSelectedProject');
      element._projectAddKeydown({key: 'a'});
      assert.isFalse(spy.called);
    });

    test('Ignores key when no ctrl/cmd', () => {
      const spy = sinon.spy(element, '_addSelectedProject');
      element._projectAddKeydown({key: 'Enter', ctrlKey: false, metaKey: false});
      assert.isFalse(spy.called);
    });

    test('Calls _addSelectedProject() when ctrl', () => {
      const spy = sinon.spy(element, '_addSelectedProject');
      element._projectAddKeydown({key: 'Enter', ctrlKey: true, metaKey: false});
      assert.isTrue(spy.called);
    });

    test('Calls _addSelectedProject() when meta', () => {
      const spy = sinon.spy(element, '_addSelectedProject');
      element._projectAddKeydown({key: 'Enter', ctrlKey: false, metaKey: true});
      assert.isTrue(spy.called);
    });
  });
  </script>
</body>

</html>
